<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1></h1><h2><a class="anchor" id="overview">
Overview</a></h2>
<p>The BrowserPlus ServiceAPI allows you to write native plugins that can be loaded by BrowserPlus. These plugins (or "services") will then be automatically scriptable by Javascript in a webpage, or whatever other execution environment is coerced to talk to BrowserPlus.</p>
<p>A service is a directory. It contains a single required file, manifest.json, which contains json text that points to the shared library (.dll or .so) that implements the service. The manifest.json also includes other information, such as localized end-user visible strings identifying at a high level what the service does, and any explicit permissions that should be requested from the user. Here is a sample manifest file for a service that displays desktop notifications: </p>
<div class="fragment"><pre class="fragment">{
  <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;standalone&quot;</span>,
  <span class="stringliteral">&quot;CoreletLibrary&quot;</span>: <span class="stringliteral">&quot;notify.dll&quot;</span>,
  <span class="stringliteral">&quot;strings&quot;</span>: {
    <span class="stringliteral">&quot;en&quot;</span>: {
      <span class="stringliteral">&quot;title&quot;</span>: <span class="stringliteral">&quot;Notify&quot;</span>,
      <span class="stringliteral">&quot;summary&quot;</span>: <span class="stringliteral">&quot;A service to deliver desktop notifications.&quot;</span>
    }
  },
  <span class="stringliteral">&quot;permissions&quot;</span>: [
    <span class="stringliteral">&quot;DisplayNotifications&quot;</span>  
  ]
}
</pre></div><p>The other entities in the service's directory are the dynamic library itself, and whatever else the service author wishes to include.</p>
<h2><a class="anchor" id="overview">
Overview</a></h2>
<p>As this API allows for native services to be authored, the first question that may arise is how do we support multiple platforms? At the time services are published, they may be marked platform specific, or platform dependent. To support multiple platforms, the only requirement is that the same service with the same version exports the same API. It is up to the service author how they wish to share code (or not) between implementations.</p>
<p>Finally, because services may be written in high level languages (Ruby being the only supported language at time of writing), it is possible to implement a service as Ruby on one platform, and native code on another.</p>
<h2><a class="anchor" id="fileOverview">
File Overview</a></h2>
<p>The ServiceAPI is a header only SDK. No libraries are required.</p>
<ul>
<li><a class="el" href="bperror_8h.html">bperror.h</a> -- Error values which go both ways across the Service/BrowserPlus boundary.</li>
<li><a class="el" href="bptypes_8h.html">bptypes.h</a> -- Structures which allow data to be represented that may be introspected. The data format defined herein is how information is transmitted across the service/BrowserPlus boundary.</li>
<li><a class="el" href="bpdefinition_8h.html">bpdefinition.h</a> -- Definitions of structures which are used to defining the interface of a service.</li>
<li><a class="el" href="bpcfunctions_8h.html">bpcfunctions.h</a> -- Functions exposed by BrowserPlus which may be invoked by a service.</li>
<li><a class="el" href="bppfunctions_8h.html">bppfunctions.h</a> -- Functions implemented by a service which will be invoked by BrowserPlus.</li>
</ul>
<p>In addition to these C header files, there are efforts to develop higher level C++ frameworks which would make authoring services even easier. Data mapping across the service boundary is perhaps the most tedious aspect of authoring a native service, and these frameworks aim to address that.</p>
<p>Feel free to contact us via the means documented elsewhere in this SDK for more information on the status of or to contribute to these C++ frameworks.</p>
<h2><a class="anchor" id="designReqs">
Design Requirements</a></h2>
<p>How did we come up with this interface? We were driven by the following requirements:</p>
<ol type="1">
<li>The interface should be as simple as possible, but no simpler.</li>
<li>services must return a description of their interface so that we may dynamically generate the functions in the target language (Javascript, possibly others).</li>
<li>non-responsive services should not render the whole system non-responsive.</li>
<li>The entire interface should be asynchronous to prevent unresponsiveness.</li>
<li>Complex return values from services must be supported.</li>
<li>The data representation must allow serialization into different formats, and must be bindable into different languages.</li>
<li>The API should not preclude cross platform services.</li>
<li>The API should be flexible enough to allow for interpreter services to be authored, which allows for the authoring of other services in high level languages.</li>
</ol>
<h2><a class="anchor" id="serviceTypes">
Service Types</a></h2>
<p>There are three different types of services, this type is specified in the service manifest (manifest.json)</p>
<ol type="1">
<li>'standalone' - Binary services implemented as a shared library</li>
<li>'provider' - Binary services implemented as a shared library that implement the BPPAttachPtr and BPPDetachPtr function pointers.</li>
<li>'dependent' - Services (not necessarily binary) that require the existence of another service to function.</li>
</ol>
<h2><a class="anchor" id="symbolSpelunking">
Symbol Spelunking</a></h2>
<p>Exactly one symbol is the contract between services and BrowserPlusCore. This symbol is BPPGetEntryPoints. All function pointers from service to BrowserPlus or vice versa are passed in a structure. This means that no import libraries are required, and only one symbol must be exported (or visible) in the service.</p>
<h2><a class="anchor" id="loadingProcedure">
Service Loading Procedure</a></h2>
<p>BPP* functions are provided by the service and called by BPCore. The service loading procedure is thus:</p>
<ol type="1">
<li>the dynamic library is loaded.</li>
<li>the "BPPGetEntryPoint" symbol is extracted and called to get a BPPFunctionTable pointer. This table contains the version of the service API to which the service was written.</li>
<li>BPPInitialize() is called which passes control to the service to attain a description of the supported functions and deliver a function table which may be used to call back into BrowserPlus.</li>
<li>BPPAllocate may be invoked from multiple threads simultaneously</li>
<li>BPPInvokePtr may be called on different allocated instances following the threading rules documented below.</li>
<li>BPPDestroy will be called once per allocated instance.</li>
<li>BPPShutdown will be called immediately before the service is unloaded from memory, and after the last BPPDestroy call.</li>
</ol>
<h2><a class="anchor" id="memoryManagement">
Memory Management</a></h2>
<p>Anything that the service allocates, the service must free. Anything that BrowserPlus allocates, BrowserPlus must free. All pointers passed into a function traveling either direction are valid only for the duration of the function, the caller may free immediately after the function returns.</p>
<h2><a class="anchor" id="threadModel">
Threading Model</a></h2>
<p>The threading model of services is designed to minimize implementation complexity for service authors, while maximizing capabilities and preventing polling. The essence is this:</p>
<ul>
<li>BPPGetEntryPoints and the BPPInitializePtr is called before any service instances are allocated (BPPAllocate).</li>
<li>BPPShutdownPtr is called after all service instances are destroyed (BPPDestroyPtr).</li>
<li>two functions on a single instance will never be called simultaneously on different threads.</li>
<li>two functions on different instances may be called at the same time from different threads.</li>
<li>all functions (BPPInvokePtr and BPPDestroyPtr) on a single instance will be called from the same thread on which BPPAllocate was called (this simplifies TLS and COM usage inside services).</li>
<li>BPC* functions may be called by the service from any thread and BrowserPlus will protect shared data structures.</li>
</ul>
<h2><a class="anchor" id="serviceDescription">
Defining your service</a></h2>
<p>After loading a service, BrowserPlus will want to know what functions the service supports and what arguments those functions accept, and the name and version of the service, etc. All of this information is conveyed through C structures documented in <a class="el" href="bpdefinition_8h.html">bpdefinition.h</a>.</p>
<h2><a class="anchor" id="dataBinding">
Data Binding</a></h2>
<p>A main purpose of services is usually to get data back to the execution environment that invoked the service. Before crossing the service &lt;-&gt; BrowserPlus boundary, data must be mapped into an intermediate format. Our solution to this problem is very similar to that of NPAPI. <a class="el" href="bptypes_8h.html">bptypes.h</a> defines a set of structures capable of holding all of the different data types we support.</p>
<p>Working with the structures directly is supported, but leads to complex code. As mentioned above, there are ongoing efforts to develop service frameworks to simplify the authoring of native services, especially in the area of data binding. Please contact us if you're interested in using or contributing to these frameworks, or have some of your own work that you would like to share.</p>
<h2><a class="anchor" id="providerServices">
Provider Services</a></h2>
<p>A "provider" service is one that can be required by a "dependent" service. This mechanism minimally affects the authors of "standalone" services while making it possible to enable services written in high level languages. Finally, while the design motivation for this mechanism was to support interpreter services, it's conceivable that it could be applied to other use cases.</p>
<p>A "provider" service may provide a native interface in the same way that "standalone" services do. In addition the provider will implement the attach and detach functions, and have a "provider" type in its service manifest instead of "standalone". A provider service will be loaded any time a dependent service that requires it is loaded. After service initialization, "attach" will be called, indicating that a dependent service is being loaded. The provider must take the arguments to attach and construct and return the definition of the dependent service. In the attach call a unique integer "attachment id" will be passed. This integer allows the provider service to disambiguate between different simultaneous attachments. This same id will be passed to the "invoke" method of the service during function invocation.</p>
<p>When the dependent service is unloaded, the detach method of the provider service will be called with the same id passed in the attach.</p>
<p>The threading contract guarantees that attach/invoke/detach will all be called on the same thread, which may be different from the thread upon which initialize is called. </p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 12 19:06:37 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
